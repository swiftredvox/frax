<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>Frax v2.23.4 — Fractal Explorer</title>
<style>
  :root{
    --bg:#0b0f14; --panel:#0f1520cc; --border:#1c293c; --text:#e6eef9; --muted:#a8b4c7;
    --chip:#121a28; --chip2:#0e1623; --accent:#78c1ff; color-scheme:dark;
  }
  html,body{ margin:0; height:100%; background:var(--bg); color:var(--text); font:14px/1.4 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Helvetica, Arial, sans-serif; }
  #wrap{ position:fixed; inset:0; display:grid; grid-template-rows:auto 1fr; }
  header{
    position:sticky; top:0; z-index:5; display:flex; flex-wrap:wrap; gap:.5rem .6rem; align-items:flex-end;
    padding:.5rem .75rem; background:var(--panel); backdrop-filter: blur(10px); border-bottom:1px solid var(--border);
  }
  .chip{
    display:flex; flex-direction:column; gap:.25rem; padding:.45rem .6rem; border:1px solid var(--border);
    border-radius:12px; background:linear-gradient(180deg,var(--chip),var(--chip2)); box-shadow: inset 0 0 0 1px rgba(255,255,255,.02);
  }
  .chip label{ font-size:11px; letter-spacing:.02em; color:var(--muted); }
  .row{ display:flex; gap:.5rem; align-items:center; flex-wrap:wrap; }
  .tight{ padding:.35rem .5rem; }
  .hint{ color:var(--muted); opacity:.85; margin-left:auto; }
  button, select, input[type="range"], input[type="number"]{
    background:#121a28; color:var(--text); border:1px solid var(--border); border-radius:10px; padding:.45rem .6rem; font:13px inherit; cursor:pointer;
  }
  button:hover{ background:#162033; }
  input[type="range"]{ accent-color:var(--accent); height:6px; cursor:pointer; }
  input[type="number"]{ width:7.2rem; }
  #canvasWrap{ position:relative; overflow:hidden; }
  canvas{ display:block; width:100%; height:100%; background:#000; }
  #hud{ position:absolute; left:.5rem; bottom:.5rem; background:rgba(8,12,18,.6); border:1px solid var(--border);
        border-radius:12px; padding:.5rem .6rem; font-size:12px; user-select:none; white-space:nowrap; backdrop-filter: blur(6px); }
  #error{ position:absolute; left:.5rem; top:.5rem; max-width:42rem; white-space:pre-wrap; background:rgba(30,60,90,.92);
          color:#fff; border:1px solid #2b5a8a; border-radius:10px; padding:.5rem .6rem; display:none; }
  .juliaRow{ display:none; gap:.4rem; align-items:center; }
</style>
</head>
<body>
<div id="wrap">
  <header>
    <div class="chip" title="Autoplay zooms toward a target">
      <label>Auto zoom</label>
      <div class="row">
        <button id="btnPlay" class="tight">▶ Auto</button>
        <input id="speed" type="range" min="0.1" max="3" step="0.1" value="1" title="Autoplay speed">
      </div>
    </div>

    <div class="chip">
      <label>Fractal</label>
      <div class="row">
        <select id="fractal">
          <!-- Mandelbrot family first -->
          <option value="mandelbrot" selected>Mandelbrot</option>
          <option value="multibrot3">Multibrot‑3</option>
          <option value="multibrot4">Multibrot‑4</option>
          <option value="multibrot5">Multibrot‑5</option>
          <!-- Burning Ship variants together -->
          <option value="burningship">Burning Ship</option>
          <option value="perpship">Perp. Burning Ship</option>
          <!-- Other -->
          <option value="celtic">Celtic</option>
          <!-- Julia last (acts differently) -->
          <option value="julia">Julia</option>
        </select>
        <div class="juliaRow" id="juliaRow">
          <input id="juliaRe" type="number" step="0.1" value="-0.7" title="Julia C (real)">
          <input id="juliaIm" type="number" step="0.1" value="-0.4" title="Julia C (imag)">
        </div>
      </div>
    </div>

    <div class="chip">
      <label>Palette</label>
      <select id="palette"></select>
    </div>

    <div class="chip" title="Increases or decreases detail by nudging iteration count">
      <label>Detail</label>
      <input id="iterBias" type="range" min="-100" max="300" step="10" value="0">
    </div>

    <div class="chip" title="Controls how intense the wheel zoom feels">
      <label>Zoom amount</label>
      <input id="zoomFeel" type="range" min="0.5" max="2" step="0.05" value="0.5">
    </div>

    <div class="chip" title="Reset view (R)">
      <label>Reset</label>
      <button id="btnReset" class="tight">Reset</button>
    </div>

    <div class="chip" title="Save a screenshot (S)">
      <label>Screenshot</label>
      <button id="btnSave" class="tight">Screenshot</button>
    </div>

    <div class="hint">Frax · Wheel: zoom to cursor · Drag: pan · [ ] palette</div>
  </header>

  <div id="canvasWrap">
    <canvas id="cv"></canvas>
    <div id="hud">Center: <span id="hCenter"></span> | Scale: <span id="hScale"></span> | Iter: <span id="hIter"></span> | FPS: <span id="hFps"></span></div>
    <div id="error"></div>
  </div>
</div>

<script>
(function(){
  "use strict";

  // ===== Error surfacing =====
  const errBox = document.getElementById('error');
  function showError(msg){ if(!errBox) return; errBox.style.display='block'; errBox.textContent=String(msg||'Unknown error'); console.error(msg); }
  function clearError(){ if(!errBox) return; errBox.style.display='none'; errBox.textContent=''; }
  window.addEventListener('error', ev=> showError(ev?.error?.stack || ev?.message || ev));
  window.addEventListener('unhandledrejection', ev=> showError(ev?.reason?.stack || ev?.reason || 'unhandled'));

  // ===== DOM =====
  const cv = document.getElementById('cv');
  const hudCenter = document.getElementById('hCenter');
  const hudScale = document.getElementById('hScale');
  const hudIter = document.getElementById('hIter');
  const hudFps = document.getElementById('hFps');
  const btnPlay = document.getElementById('btnPlay');
  const btnReset = document.getElementById('btnReset');
  const btnSave = document.getElementById('btnSave');
  const speed = document.getElementById('speed');
  const paletteSel = document.getElementById('palette');
  const iterBias = document.getElementById('iterBias');
  const zoomFeel = document.getElementById('zoomFeel');
  const fractalSel = document.getElementById('fractal');
  const juliaRow = document.getElementById('juliaRow');
  const juliaRe = document.getElementById('juliaRe');
  const juliaIm = document.getElementById('juliaIm');

  // ===== Helpers =====
  function DPR(){ return Math.max(1, Math.min(2.5, window.devicePixelRatio||1)); }
  function hslToRgb(h, s, l){
    function hue2rgb(p, q, t){ if(t<0) t+=1; if(t>1) t-=1; if(t<1/6) return p + (q - p) * 6 * t;
      if(t<1/2) return q; if(t<2/3) return p + (q - p) * (2/3 - t) * 6; return p; }
    let r,g,b;
    if(s===0){ r=g=b=l; }
    else {
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      r = hue2rgb(p, q, h + 1/3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1/3);
    }
    return [Math.round(r*255), Math.round(g*255), Math.round(b*255)];
  }

  // ===== Defaults & state =====
  const defaults = {
    mandelbrot: {cx:-0.743643887037151, cy:0.13182590420533, vw:3.5, tx:-0.743643887037151, ty:0.13182590420533},
    multibrot3: {cx:-0.5, cy:0.0, vw:3.5, tx:-0.5, ty:0.0},
    multibrot4: {cx:-0.75, cy:0.0, vw:3.5, tx:-0.75, ty:0.0},
    multibrot5: {cx:-0.9, cy:0.0, vw:3.5, tx:-0.9, ty:0.0},
    burningship:{cx:-1.74, cy:-0.03, vw:3.5, tx:-1.76, ty:-0.02},
    perpship:   {cx:-1.75, cy:-0.03, vw:3.5, tx:-1.78, ty:-0.03},
    celtic:     {cx:-0.6, cy:0.4, vw:3.5, tx:-0.6, ty:0.4},
    julia:      {cx:0.0, cy:0.0, vw:3.5, tx:0.0, ty:0.0}
  };
  let centerX = defaults.mandelbrot.cx;
  let centerY = defaults.mandelbrot.cy;
  let viewWidth = defaults.mandelbrot.vw;
  let autoplay = false;
  let fpsSmoothed = 0, lastFrame = performance.now();
  let baseIterations = 150;
  let scaleK = 70;

  // ===== Palettes (explicit order; Spectrum last) =====
  const paletteEntries = [
    ["Oceanic", [[0, 12, 28],[0, 68, 120],[0, 140, 200],[120, 220, 255],[245, 250, 255]]],
    ["InfernoLite", [[0,0,0],[40,0,30],[120,0,60],[220,80,30],[255,220,80]]],
    ["Aurora", [[4,10,22],[10,60,80],[40,160,120],[160,240,200],[250,250,255]]],
    ["Velvet", [[8,8,16],[60,20,60],[120,30,120],[200,60,160],[255,180,230]]],
    ["Mono", [[0,0,0],[64,64,64],[128,128,128],[192,192,192],[255,255,255]]],
    ["Classic", [[0,7,27],[32,107,203],[237,255,255],[255,170,0],[0,2,0]]],
    ["Sunset", [[10,2,20],[90,10,70],[200,40,60],[255,120,80],[255,230,180]]],
    ["Neon", [[5,5,10],[20,220,160],[60,80,255],[255,60,200],[250,255,255]]],
    ["Forest", [[4,10,6],[20,60,20],[40,120,50],[120,200,120],[230,255,230]]],
    ["Icefire", [[0,0,0],[30,40,120],[80,160,255],[255,130,80],[255,240,210]]],
    ["Magma", [[0,0,3],[30,10,50],[120,20,80],[230,70,30],[255,200,120]]],
    ["Twilight", [[0,0,0],[45,15,60],[70,40,120],[150,170,200],[240,230,255]]],
    ["Copper", [[0,0,0],[60,30,10],[120,70,30],[190,120,70],[255,220,170]]],
    ["Candy", [[20,10,30],[255,80,160],[160,240,255],[120,80,255],[250,240,255]]],
    ["Midnight", [[2,6,16],[8,18,40],[20,40,80],[60,110,160],[200,240,255]]],
    ["Solar", [[0,0,0],[10,20,60],[120,120,20],[240,180,20],[255,250,200]]],
    ["Lavender", [[10,8,24],[60,40,120],[120,90,200],[200,160,240],[245,240,255]]],
    ["Spectrum (cycle)", [[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0]]]
  ];
  const palettes = Object.fromEntries(paletteEntries);
  for(const [name] of paletteEntries){
    const o = document.createElement('option');
    o.value=name; o.textContent=name;
    if (name==='Oceanic') o.selected = true;
    paletteSel.appendChild(o);
  }
  const paletteNames = paletteEntries.map(([n])=>n);

  // Spectrum state (single declaration)
  let cycleActive = false;
  let cycleStart = performance.now();
  const cycleSpeed = 0.12; // faster hue rotation (~3x v2.23.2)

  // ===== GL init =====
  let gl = null, prog = null;
  try{
    gl = cv.getContext('webgl', {antialias:false, depth:false, stencil:false, premultipliedAlpha:false, preserveDrawingBuffer:true});
    if(!gl) throw new Error('WebGL unavailable.');
  }catch(e){ showError(e.message||e); return; }

  function resize(){
    try{
      const dpr = DPR();
      const w = cv.clientWidth || window.innerWidth;
      const h = cv.clientHeight || (window.innerHeight - (document.querySelector('header')?.offsetHeight||0));
      const pxW = Math.max(1, Math.floor(w * dpr));
      const pxH = Math.max(1, Math.floor(h * dpr));
      if (cv.width!==pxW || cv.height!==pxH){
        cv.width = pxW; cv.height = pxH;
        gl.viewport(0,0,gl.drawingBufferWidth, gl.drawingBufferHeight);
      }
    }catch(e){ showError(e.message||e); }
  }
  if ('ResizeObserver' in window){
    new ResizeObserver(resize).observe(document.getElementById('canvasWrap'));
  } else {
    window.addEventListener('resize', resize);
  }
  resize();

  // ===== Shaders =====
  const vsSrc = `
    attribute vec2 aPos;
    void main(){ gl_Position = vec4(aPos,0.0,1.0); }
  `;
  const fsSrc = `
    precision highp float;
    uniform vec2 uCenter;
    uniform float uViewW;
    uniform vec2 uRes;
    uniform int uMaxIter;
    uniform vec3 uP0, uP1, uP2, uP3, uP4;
    // 0=mandelbrot,1=julia,2=burning ship,3=multibrot3,4=multibrot4,5=multibrot5,6=celtic,7=perp ship
    uniform int uMode;
    uniform vec2 uJuliaC;
    const int MAX_ITERS = 2000;

    void main(){
      vec2 frag = gl_FragCoord.xy;
      float aspect = uRes.y / uRes.x;
      float viewH = uViewW * aspect;

      float x = (frag.x / uRes.x - 0.5) * uViewW + uCenter.x;
      float y = (frag.y / uRes.y - 0.5) * viewH + uCenter.y;

      float zr, zi, cr, ci;
      if (uMode == 1) { zr = x; zi = y; cr = uJuliaC.x; ci = uJuliaC.y; }
      else { zr = 0.0; zi = 0.0; cr = x; ci = y; }

      float zr2 = zr*zr, zi2 = zi*zi;
      int iter=0;
      for (int i=0;i<MAX_ITERS;++i){
        if (i>=uMaxIter) break;
        float nzr, nzi;

        if (uMode == 2) {
          float azr = abs(zr), azi = abs(zi);
          nzr = azr*azr - azi*azi + cr;
          nzi = 2.0*azr*azi + ci;
        } else if (uMode == 3) {
          nzr = (zr * (zr2 - 3.0*zi2)) + cr;
          nzi = (zi * (3.0*zr2 - zi2)) + ci;
        } else if (uMode == 4) {
          float r2 = zr2, i2 = zi2;
          nzr = r2*r2 - 6.0*r2*i2 + i2*i2 + cr;
          nzi = 4.0*zr*zi*(r2 - i2) + ci;
        } else if (uMode == 5) {
          vec2 z = vec2(zr, zi);
          vec2 z2 = vec2(zr2 - zi2, 2.0*zr*zi);
          vec2 z4 = vec2(z2.x*z2.x - z2.y*z2.y, 2.0*z2.x*z2.y);
          vec2 z5 = vec2(z4.x*z.x - z4.y*z.y, z4.x*z.y + z4.y*z.x);
          nzr = z5.x + cr;
          nzi = z5.y + ci;
        } else if (uMode == 6) {
          float rr = zr2 - zi2;
          float ii = 2.0*zr*zi;
          nzr = abs(rr) + cr;
          nzi = ii + ci;
        } else if (uMode == 7) {
          float azr = abs(zr), azi = abs(zi);
          nzr = azr*azr - azi*azi + cr;
          nzi = -2.0*azr*azi + ci;
        } else {
          nzi = 2.0*zr*zi + ci;
          nzr = zr2 - zi2 + cr;
        }

        zr = nzr; zi = nzi;
        zr2 = zr*zr; zi2 = zi*zi;
        iter = i;
        if ((zr2+zi2)>4.0) break;
      }

      float t;
      if ((zr2+zi2)>4.0){
        float nu = float(iter) + 1.0 - log(log(sqrt(zr2+zi2))) / log(2.0);
        t = clamp(nu / float(uMaxIter), 0.0, 1.0);
      } else {
        t = 0.0;
      }

      vec3 c;
      if (t <= 0.25) { float k=t/0.25; c = mix(uP0,uP1,k); }
      else if (t <= 0.5) { float k=(t-0.25)/0.25; c = mix(uP1,uP2,k); }
      else if (t <= 0.75) { float k=(t-0.5)/0.25; c = mix(uP2,uP3,k); }
      else { float k=(t-0.75)/0.25; c = mix(uP3,uP4,k); }
      gl_FragColor = vec4(c/255.0, 1.0);
    }
  `;
  function compile(type,src){
    const s = gl.createShader(type);
    gl.shaderSource(s,src);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)){
      const info = gl.getShaderInfoLog(s);
      showError('Shader compile error:\\n'+info);
      throw new Error(info||'shader compile failed');
    }
    return s;
  }
  try{
    const vs = compile(gl.VERTEX_SHADER, vsSrc);
    const fs = compile(gl.FRAGMENT_SHADER, fsSrc);
    const program = gl.createProgram();
    gl.attachShader(program,vs); gl.attachShader(program,fs);
    gl.bindAttribLocation(program,0,'aPos');
    gl.linkProgram(program);
    if(!gl.getProgramParameter(program,gl.LINK_STATUS)){
      const info = gl.getProgramInfoLog(program);
      showError('Program link error:\\n'+info);
      throw new Error(info||'program link failed');
    }
    gl.useProgram(program);
    prog = program;
  }catch(e){ return; }

  // ===== Fullscreen triangle =====
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([ -1,-1, 3,-1, -1,3 ]), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(0);
  gl.vertexAttribPointer(0,2,gl.FLOAT,false,0,0);

  // ===== Uniforms =====
  const uCenter = gl.getUniformLocation(prog,'uCenter');
  const uViewW  = gl.getUniformLocation(prog,'uViewW');
  const uRes    = gl.getUniformLocation(prog,'uRes');
  const uMaxIter= gl.getUniformLocation(prog,'uMaxIter');
  const uP = [
    gl.getUniformLocation(prog,'uP0'),
    gl.getUniformLocation(prog,'uP1'),
    gl.getUniformLocation(prog,'uP2'),
    gl.getUniformLocation(prog,'uP3'),
    gl.getUniformLocation(prog,'uP4')
  ];
  const uMode    = gl.getUniformLocation(prog,'uMode');
  const uJuliaC  = gl.getUniformLocation(prog,'uJuliaC');

  // ===== Palettes =====
  function applyStops(stops){
    for(let i=0;i<5;i++){ gl.uniform3fv(uP[i], new Float32Array(stops[i])); }
  }
  function setCyclePalette(tSec){
    // darker, but brighter than 2.23.2 for mid/highs to avoid washed-out look
    const baseHue = (tSec * cycleSpeed) % 1;
    const sBase = 0.35; // subdued saturation
    const lightness = [0.05, 0.09, 0.15, 0.24, 0.40]; // lifted slightly
    const stops = [];
    for(let i=0;i<5;i++){
      const h = (baseHue + i*0.18) % 1;
      const s = sBase * (1.0 - i*0.10);
      const rgb = hslToRgb(h, s, lightness[i]);
      stops.push(rgb);
    }
    applyStops(stops);
  }
  function setPalette(name){
    cycleActive = (name === "Spectrum (cycle)");
    if (cycleActive){
      setCyclePalette((performance.now() - cycleStart) / 1000);
    } else {
      const pal = palettes[name] || palettes["Oceanic"];
      const stops = pal.length>=5 ? pal : pal.concat(new Array(5-pal.length).fill(pal[pal.length-1])).slice(0,5);
      applyStops(stops);
    }
  }
  setPalette(paletteSel.value);

  // ===== Input =====
  let dragging=false, dragStart=null;
  cv.addEventListener('pointerdown', e=>{
    dragging=true; cv.setPointerCapture(e.pointerId);
    dragStart = { x:e.clientX, y:e.clientY, cx:centerX, cy:centerY };
  });
  cv.addEventListener('pointermove', e=>{
    if(!dragging||!dragStart) return;
    const dpr = DPR();
    const dx = (e.clientX - dragStart.x) * dpr;
    const dy = (e.clientY - dragStart.y) * dpr;
    const scale = viewWidth / cv.width;
    centerX = dragStart.cx - dx * scale;
    centerY = dragStart.cy + dy * scale * (cv.height / cv.width);
  });
  cv.addEventListener('pointerup', ()=>{ dragging=false; dragStart=null; });

  // Zoom to cursor with adjustable amount
  cv.addEventListener('wheel', e=>{
    e.preventDefault();
    const dpr = DPR();
    const rect = cv.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * dpr;
    const myTop = (e.clientY - rect.top) * dpr;
    const my = (cv.height - myTop);
    const aspect = cv.height / cv.width;

    const worldX = centerX + (mx / cv.width - 0.5) * viewWidth;
    const worldY = centerY + (my / cv.height - 0.5) * viewWidth * aspect;

    const LINE = 1, PIXEL = 0;
    const baseStep = (e.deltaMode===LINE) ? 0.08 : 0.0025;
    const step = baseStep * parseFloat(zoomFeel.value);
    const zoom = Math.exp(-e.deltaY * step);

    viewWidth *= 1/zoom;
    centerX = worldX - (mx / cv.width - 0.5) * viewWidth;
    centerY = worldY - (my / cv.height - 0.5) * viewWidth * aspect;
  }, {passive:false});

  // ===== Keys and UI =====
  window.addEventListener('keydown', e=>{
    if (e.key==='p'||e.key==='P') togglePlay();
    else if (e.key==='r'||e.key==='R') resetView();
    else if (e.key==='s'||e.key==='S') savePNG();
    else if (e.key==='[') stepPalette(-1);
    else if (e.key===']') stepPalette(+1);
  });
  btnReset.onclick = resetView;
  btnSave.onclick = savePNG;
  btnPlay.onclick = togglePlay;
  paletteSel.onchange = ()=> setPalette(paletteSel.value);
  fractalSel.onchange = onFractalChange;

  function resetView(){
    const d = defaults[fractalSel.value] || defaults.mandelbrot;
    centerX = d.cx; centerY = d.cy; viewWidth = d.vw;
  }
  function savePNG(){
    const a = document.createElement('a');
    a.download = 'frax_screenshot.png';
    a.href = cv.toDataURL('image/png');
    a.click();
  }
  function togglePlay(){
    autoplay = !autoplay;
    btnPlay.textContent = autoplay ? '❚❚ Pause' : '▶ Auto';
  }
  function stepPalette(dir){
    let i = paletteNames.indexOf(paletteSel.value);
    i = (i + dir + paletteNames.length) % paletteNames.length;
    paletteSel.value = paletteNames[i];
    setPalette(paletteSel.value);
  }

  // Auto zoom targets per fractal
  function getTarget(){
    const f = fractalSel.value;
    const d = defaults[f] || defaults.mandelbrot;
    return {x:d.tx, y:d.ty};
  }
  function stepAuto(dt){
    if (!autoplay) return;
    const spd = parseFloat(speed.value);
    const t = Math.pow(0.995, spd * 60.0 * dt);
    viewWidth *= t;
    const tgt = getTarget();
    centerX = tgt.x + (centerX - tgt.x) * t;
    centerY = tgt.y + (centerY - tgt.y) * t;
  }

  // ===== Draw =====
  const uCenterLoc = uCenter;
  const uViewWLoc = uViewW;
  const uResLoc = uRes;
  const uMaxIterLoc = uMaxIter;
  const uModeLoc = uMode;
  const uJuliaCLoc = uJuliaC;

  function draw(){
    try{
      gl.useProgram(prog);
      gl.viewport(0,0,gl.drawingBufferWidth, gl.drawingBufferHeight);
      gl.uniform2f(uCenterLoc, centerX, centerY);
      gl.uniform1f(uViewWLoc, viewWidth);
      gl.uniform2f(uResLoc, gl.drawingBufferWidth, gl.drawingBufferHeight);

      const zoom = 3.5 / viewWidth;
      const iters = Math.max(50, Math.floor(baseIterations + scaleK * Math.log(1.0 + zoom) + (+iterBias.value)));
      gl.uniform1i(uMaxIterLoc, Math.min(iters, 1800));

      let mode = 0;
      if (fractalSel.value==='julia') mode = 1;
      else if (fractalSel.value==='burningship') mode = 2;
      else if (fractalSel.value==='multibrot3') mode = 3;
      else if (fractalSel.value==='multibrot4') mode = 4;
      else if (fractalSel.value==='multibrot5') mode = 5;
      else if (fractalSel.value==='celtic') mode = 6;
      else if (fractalSel.value==='perpship') mode = 7;
      gl.uniform1i(uModeLoc, mode);

      function clamp1dp(v){ return Math.round(parseFloat(v || "0") * 10) / 10; }
      juliaRe.value = clamp1dp(juliaRe.value).toFixed(1);
      juliaIm.value = clamp1dp(juliaIm.value).toFixed(1);
      gl.uniform2f(uJuliaCLoc, parseFloat(juliaRe.value), parseFloat(juliaIm.value));

      if (cycleActive){
        const tSec = (performance.now() - cycleStart) / 1000;
        setCyclePalette(tSec);
      }

      gl.drawArrays(gl.TRIANGLES,0,3);
      updateHUD(iters);
      clearError();
    }catch(e){
      showError(e.message||e);
    }
  }

  function updateHUD(iter){
    const now = performance.now();
    const dt = (now - lastFrame) / 1000;
    lastFrame = now;
    const fps = 1 / Math.max(0.001, dt);
    fpsSmoothed = fpsSmoothed ? fpsSmoothed * 0.9 + fps * 0.1 : fps;
    hudFps.textContent = fpsSmoothed.toFixed(0);
    hudCenter.textContent = fmt(centerX)+', '+fmt(centerY);
    hudScale.textContent = fmt(viewWidth);
    hudIter.textContent = String(iter);
  }
  function fmt(n){
    const a = Math.abs(n);
    const d = a >= 1 ? 4 : a >= 1e-2 ? 6 : 8;
    return n.toFixed(d);
  }

  function onFractalChange(){
    const f = fractalSel.value;
    juliaRow.style.display = (f==='julia') ? 'flex' : 'none';
    const d = defaults[f] || defaults.mandelbrot;
    centerX = d.cx; centerY = d.cy; viewWidth = d.vw;
  }
  onFractalChange();

  function raf(){
    const dt = 0.016;
    stepAuto(dt);
    draw();
    requestAnimationFrame(raf);
  }
  requestAnimationFrame(raf);
})();
</script>
</body>
</html>
